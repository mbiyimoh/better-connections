generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                      String                @id @default(uuid())
  email                   String                @unique
  name                    String
  emailNotifications      Boolean               @default(true)
  weeklyDigest            Boolean               @default(true)
  enrichmentReminders     Boolean               @default(false)
  createdAt               DateTime              @default(now())
  updatedAt               DateTime              @updatedAt
  lastLoginAt             DateTime?
  hasCompletedOnboarding  Boolean               @default(false)
  lastSeenUpdateVersion   String?               // ISO date string (e.g., "2026-01-15") for What's New tracking
  role                    UserRole              @default(USER)
  contacts                Contact[]
  contactMentions         ContactMention[]
  contactRelationships    ContactRelationship[]
  enrichmentStreaks       EnrichmentStreak[]
  feedbackSubmissions     Feedback[]
  feedbackVotes           FeedbackVote[]
  researchRuns            ContactResearchRun[]
  events                  Event[]               // M33T: Events organized by user
  hasM33tAccess           Boolean               @default(false) // Feature flag for M33T Events access
  eventOrganizers         EventOrganizer[]      // M33T: Events where user is a co-organizer

  // M33T audit relations
  attendeesAdded           EventAttendee[] @relation("AttendeeAddedBy")
  attendeeOverridesEdited  EventAttendee[] @relation("AttendeeOverridesEditedBy")
  attendeeOrderUpdated     EventAttendee[] @relation("AttendeeOrderUpdatedBy")

  // M33T Invitee Auth: Account origin and phone verification
  accountOrigin            AccountOrigin   @default(BETTER_CONTACTS)
  betterContactsActivated  Boolean         @default(true)  // false for M33T_INVITEE until upgraded
  phone                    String?         // E.164 format for SMS
  phoneVerified            Boolean         @default(false)
  phoneVerifiedAt          DateTime?
  linkedAttendees          EventAttendee[] @relation("AttendeeLinkedUser")
  phoneVerificationOTPs    PhoneVerificationOTP[]
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model Contact {
  id                   String                @id @default(uuid())
  userId               String
  title                String?               // Job role (e.g., "Venture Capitalist", "Software Engineer")
  organizationalTitle  String?               // Position within organization (e.g., "President", "VP of Engineering")
  company              String?
  location             String?
  linkedinUrl          String?
  howWeMet             String?
  relationshipStrength Int                   @default(1)
  lastContactDate      DateTime?
  relationshipHistory  String?
  whyNow               String?
  expertise            String?
  interests            String?
  notes                String?
  enrichmentScore      Int                   @default(0)
  source               ContactSource         @default(MANUAL)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  lastEnrichedAt       DateTime?
  firstName            String                @default("")
  lastName             String?
  primaryEmail         String?
  primaryPhone         String?
  secondaryEmail       String?
  secondaryPhone       String?
  city                 String?
  country              String?
  referredBy           String?
  state                String?
  streetAddress        String?
  websiteUrl           String?
  zipCode              String?
  // Social media profiles
  twitterUrl           String?
  githubUrl            String?
  instagramUrl         String?
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  mentionsAsTarget     ContactMention[]      @relation("MentionTarget")
  mentionsAsSource     ContactMention[]      @relation("MentionSource")
  relationshipsA       ContactRelationship[] @relation("RelationshipA")
  relationshipsB       ContactRelationship[] @relation("RelationshipB")
  tags                 Tag[]
  researchRuns         ContactResearchRun[]
  enrichmentLogs       ContactEnrichmentLog[]
  eventAttendees       EventAttendee[]       // M33T: Contact linked to event attendance

  @@index([userId])
  @@index([firstName])
  @@index([lastName])
  @@index([primaryEmail])
  @@index([enrichmentScore])
}

model Tag {
  id        String      @id @default(uuid())
  contactId String
  text      String
  category  TagCategory
  contact   Contact     @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@index([contactId])
}

model EnrichmentStreak {
  id               String   @id @default(uuid())
  userId           String
  weekStart        DateTime
  contactsEnriched Int      @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, weekStart])
  @@index([userId])
}

model ContactRelationship {
  id            String             @id @default(uuid())
  userId        String
  contactAId    String
  contactBId    String
  sourceType    RelationshipSource @default(ENRICHMENT_MENTION)
  sourceContext String?
  createdAt     DateTime           @default(now())
  contactA      Contact            @relation("RelationshipA", fields: [contactAId], references: [id], onDelete: Cascade)
  contactB      Contact            @relation("RelationshipB", fields: [contactBId], references: [id], onDelete: Cascade)
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([contactAId, contactBId])
  @@index([userId])
  @@index([contactAId])
  @@index([contactBId])
}

model ContactMention {
  id                 String        @id @default(uuid())
  userId             String
  sourceContactId    String
  mentionedContactId String?
  mentionedName      String
  normalizedName     String
  extractedContext   String
  inferredFields     Json?
  matchConfidence    Float         @default(0)
  matchType          MatchType?
  status             MentionStatus @default(PENDING)
  createdAt          DateTime      @default(now())
  processedAt        DateTime?
  mentionedContact   Contact?      @relation("MentionTarget", fields: [mentionedContactId], references: [id])
  sourceContact      Contact       @relation("MentionSource", fields: [sourceContactId], references: [id], onDelete: Cascade)
  user               User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sourceContactId])
  @@index([status])
}

// Contact Deep Research models
model ContactResearchRun {
  id              String         @id @default(cuid())
  contactId       String
  userId          String

  // Research configuration
  searchQuery     String         // Optimized query sent to Tavily
  focusAreas      String[]       // ["professional", "expertise", "interests", "news"]

  // Status tracking
  status          ResearchStatus @default(PENDING)
  progressStage   String?        // "Searching...", "Analyzing...", "Generating recommendations..."
  errorMessage    String?

  // Results
  summary         String?        @db.Text  // Bullet summary for quick display
  fullReport      String?        @db.Text  // Detailed markdown report
  sourceUrls      String[]       // All sources found during research

  // Metadata
  startedAt       DateTime?
  completedAt     DateTime?
  executionTimeMs Int?

  // Apply tracking (for post-apply celebration and history)
  appliedChangesSummary String?    @db.Text  // JSON array of change descriptions
  appliedAt             DateTime?            // When recommendations were applied
  previousScore         Int?                 // Enrichment score before apply
  newScore              Int?                 // Enrichment score after apply

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  contact         Contact        @relation(fields: [contactId], references: [id], onDelete: Cascade)
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  recommendations ContactRecommendation[]

  @@index([contactId])
  @@index([userId, createdAt])
  @@index([status])
}

model ContactRecommendation {
  id              String               @id @default(cuid())
  researchRunId   String

  // What to update
  fieldName       String               // expertise | interests | whyNow | notes | title | company | location | tags
  action          RecommendationAction // ADD (empty field) | UPDATE (existing value)
  currentValue    String?              @db.Text  // For comparison/diff display
  proposedValue   String               @db.Text  // The suggested new value

  // For tag recommendations (fieldName = "tags")
  tagCategory     String?              // RELATIONSHIP | OPPORTUNITY | EXPERTISE | INTEREST

  // Justification
  reasoning       String               @db.Text  // Why this recommendation was made
  confidence      Float                // 0.0 - 1.0
  sourceUrls      String[]             // Specific sources for this recommendation

  // Status
  status          RecommendationStatus @default(PENDING)
  editedValue     String?              @db.Text  // User-edited value (if different from proposed)
  reviewedAt      DateTime?
  appliedAt       DateTime?

  createdAt       DateTime             @default(now())

  // Relations
  researchRun     ContactResearchRun   @relation(fields: [researchRunId], references: [id], onDelete: Cascade)

  @@index([researchRunId, status])
  @@index([researchRunId, fieldName])
}

model ContactEnrichmentLog {
  id              String   @id @default(cuid())
  contactId       String

  fieldName       String
  previousValue   String?  @db.Text
  newValue        String   @db.Text
  source          String   // MANUAL | VOICE | RESEARCH | IMPORT
  researchRunId   String?  // Reference to research run if source = RESEARCH

  createdAt       DateTime @default(now())

  // Relations
  contact         Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@index([contactId, createdAt])
  @@index([source])
}

model Feedback {
  id          String               @id @default(cuid())
  userId      String
  title       String               @db.VarChar(200)
  description String
  area        FeedbackArea
  type        FeedbackType
  status      FeedbackStatus       @default(OPEN)
  upvoteCount Int                  @default(0)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  user        User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  attachments FeedbackAttachment[]
  votes       FeedbackVote[]

  @@index([userId])
  @@index([status])
  @@index([area])
  @@index([type])
  @@index([createdAt])
  @@index([upvoteCount])
}

model FeedbackVote {
  id         String   @id @default(cuid())
  feedbackId String
  userId     String?
  visitorId  String?
  createdAt  DateTime @default(now())
  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  user       User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([feedbackId, userId])
  @@unique([feedbackId, visitorId])
  @@index([feedbackId])
  @@index([userId])
}

model FeedbackAttachment {
  id         String    @id @default(cuid())
  feedbackId String?
  fileName   String
  fileSize   Int
  mimeType   String
  url        String
  createdAt  DateTime  @default(now())
  uploadedBy String
  feedback   Feedback? @relation(fields: [feedbackId], references: [id], onDelete: Cascade)

  @@index([feedbackId])
  @@index([uploadedBy])
}

enum UserRole {
  USER
  SYSTEM_ADMIN
}

// M33T Invitee Auth: Account origin tracking
enum AccountOrigin {
  BETTER_CONTACTS
  M33T_INVITEE
}

enum ContactSource {
  MANUAL
  CSV
  GOOGLE
  LINKEDIN
  ICLOUD
  OUTLOOK
}

enum TagCategory {
  RELATIONSHIP
  OPPORTUNITY
  EXPERTISE
  INTEREST
}

enum RelationshipSource {
  ENRICHMENT_MENTION
  MANUAL
  IMPORT
}

enum MentionStatus {
  PENDING
  LINKED
  CREATED
  DISMISSED
}

enum MatchType {
  EXACT
  FUZZY
  PHONETIC
  NONE
}

enum FeedbackArea {
  CONTACTS
  ENRICHMENT
  EXPLORE
  IMPORT_EXPORT
  MOBILE
  OTHER
}

enum FeedbackType {
  BUG
  ENHANCEMENT
  IDEA
  QUESTION
}

enum FeedbackStatus {
  OPEN
  IN_REVIEW
  PLANNED
  IN_PROGRESS
  COMPLETED
  CLOSED
}

// Contact Deep Research enums
enum ResearchStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum RecommendationStatus {
  PENDING
  APPROVED
  REJECTED
  APPLIED
}

enum RecommendationAction {
  ADD
  UPDATE
}

// ========== M33T EVENT NETWORKING ENUMS ==========

enum EventStatus {
  DRAFT
  PUBLISHED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum RevealTiming {
  IMMEDIATE
  TWENTY_FOUR_HOURS_BEFORE
  FORTY_EIGHT_HOURS_BEFORE
}

enum RSVPStatus {
  PENDING
  CONFIRMED
  MAYBE
  DECLINED
}

enum MatchStatus {
  PENDING    // AI-generated, awaiting review
  APPROVED   // Organizer approved
  REJECTED   // Organizer rejected
  REVEALED   // Sent to attendee
}

enum QuestionSetStatus {
  DRAFT      // Not visible to attendees
  PUBLISHED  // Visible and completable by attendees
  ARCHIVED   // Hidden but preserved (for data integrity)
}

// ========== M33T EVENT MODEL ==========

model Event {
  id                String   @id @default(cuid())
  userId            String   // Primary Organizer
  user              User     @relation(fields: [userId], references: [id])

  // Basic Info
  name              String
  tagline           String?
  description       String?

  // Timing
  date              DateTime
  startTime         String   // "18:00"
  endTime           String   // "21:00"
  timezone          String   @default("America/Chicago")

  // Location
  venueName         String
  venueAddress      String
  venueLatitude     Float?             // For map display
  venueLongitude    Float?             // For map display
  googlePlaceId     String?            // Google Places ID for photos

  // New wizard fields
  eventType         String?          // networking, conference, workshop, social, other
  eventGoals        String[]         // fundraising, hiring, partnerships, learning, community
  parkingNotes      String?
  dressCode         String?          // casual, business-casual, formal, creative
  foodInfo          String?          // Food and drinks info for attendees

  // Settings
  capacity          Int      @default(50)
  rsvpDeadline      DateTime?

  // Questionnaire (inline JSON instead of separate model)
  questions         Json     @default("[]") // Array of Question objects

  // Card Display Settings
  cardSettings      Json     @default("{}") // { showCompany, showRole, showExpertise }

  // Match Settings
  matchesPerAttendee Int     @default(5)
  revealTiming       RevealTiming @default(TWENTY_FOUR_HOURS_BEFORE)

  // Status
  status            EventStatus @default(DRAFT)

  // Public Landing Page
  slug              String?   @unique  // URL-safe identifier for /events/[slug]
  schedule          Json?              // Array of { time, title, description }
  hostName          String?            // Override account name for host section (legacy single host)
  hostTitle         String?            // Host title (legacy single host)
  hostBio           String?            // Bio text (legacy single host)
  hostQuote         String?            // Quote text (legacy single host)
  hostPhoto         String?            // URL to host photo (legacy single host)
  hosts             Json?              // Array of { id, name, title, bio, quote, photo } for multiple hosts
  whatToExpect      Json?              // Array of { id, icon, title, description }
  landingPageSettings Json   @default("{}")  // { showVenue, showSchedule, showHost, showWhatToExpect, showAttendees }

  // Relations
  attendees         EventAttendee[]
  matches           Match[]
  organizers        EventOrganizer[]  // Co-organizers with permissions
  questionSets      QuestionSet[]     // Multi-phase questionnaire sets

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@index([date])
  @@index([status])
  @@index([slug])
}

// ========== M33T QUESTION SET MODELS ==========

model QuestionSet {
  id          String   @id @default(cuid())
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Identity
  internalId  String   // Auto-generated: "set_1", "set_2", etc.
  title       String   // User-defined display title
  description String?  // Optional description shown to attendees

  // Questions (same schema as current Question type)
  questions   Json     @default("[]") // Array of Question objects

  // Lifecycle
  status      QuestionSetStatus @default(DRAFT)
  publishedAt DateTime?

  // Ordering
  order       Int      @default(0)    // Display order among sets

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  responses   QuestionSetResponse[]

  @@unique([eventId, internalId])
  @@index([eventId, status])
}

model QuestionSetResponse {
  id              String      @id @default(cuid())
  questionSetId   String
  questionSet     QuestionSet @relation(fields: [questionSetId], references: [id], onDelete: Cascade)
  attendeeId      String
  attendee        EventAttendee @relation(fields: [attendeeId], references: [id], onDelete: Cascade)

  // Response Data
  responses       Json        @default("[]") // Array of { questionId, value, context?, answeredAt }

  // AI-Generated Suggestions (populated on completion)
  suggestions     Json?       // Array of ProfileSuggestion objects

  // Completion State
  completedAt     DateTime?   // null = in progress, set = completed

  // Timestamps
  startedAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@unique([questionSetId, attendeeId])
  @@index([attendeeId])
}

// ========== M33T ATTENDEE MODEL ==========

model EventAttendee {
  id              String   @id @default(cuid())
  eventId         String
  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Link to Better Contacts (optional)
  contactId       String?
  contact         Contact? @relation(fields: [contactId], references: [id])

  // Link to authenticated User (for M33T invitees)
  userId          String?
  user            User?    @relation("AttendeeLinkedUser", fields: [userId], references: [id])

  // Basic Info (at least one of email or phone required for invites)
  email           String?
  phone           String?  // E.164 format for SMS
  firstName       String
  lastName        String?

  // RSVP Status
  rsvpStatus      RSVPStatus @default(PENDING)
  rsvpRespondedAt DateTime?

  // Questionnaire Response (inline JSON)
  questionnaireResponses Json? // Array of { questionId, value, context?, answeredAt }
  questionnaireCompletedAt DateTime?

  // Extracted Profile (inline JSON instead of separate model)
  profile            Json?     // See ProfileSchema
  profileExtractedAt DateTime?

  // Organizer Profile Customizations (event-specific overrides)
  profileOverrides   Json?     // Sparse overrides (see ProfileOverridesSchema)
  overridesEditedAt  DateTime? // Last override edit timestamp

  // Audit: Who added this attendee to the event
  addedById             String?
  addedBy               User?     @relation("AttendeeAddedBy", fields: [addedById], references: [id])

  // Audit: Who last edited profile overrides
  overridesEditedById   String?
  overridesEditedBy     User?     @relation("AttendeeOverridesEditedBy", fields: [overridesEditedById], references: [id])

  // Attendee Ordering (for custom display order on landing page)
  displayOrder          Int?                      // null = auto-sort, number = pinned position
  profileRichness       Int       @default(0)     // 0-100 computed score for auto-sorting

  // Audit: Who last updated the display order
  orderUpdatedById      String?
  orderUpdatedBy        User?     @relation("AttendeeOrderUpdatedBy", fields: [orderUpdatedById], references: [id])
  orderUpdatedAt        DateTime?

  // Matching Fields (extracted and indexed for queries)
  goalsText       String?  // Raw text for future embedding
  idealMatchText  String?  // Raw text for future embedding
  experienceLevel String?  // early | mid | senior | executive | founder
  topicsOfInterest String[] // For rule-based matching
  expertise       String[] // For rule-based matching
  seekingKeywords String[] // Extracted keywords from goals
  offeringKeywords String[] // Extracted keywords from offerings

  // Trading Card (cached display data)
  tradingCard     Json?    // L1-L3 data

  // Matches
  matches         Match[]  @relation("AttendeeMatches")
  matchedWith     Match[]  @relation("MatchedWithAttendee")

  // Question Set Responses (multi-phase questionnaires)
  questionSetResponses QuestionSetResponse[]

  // Notification tracking (simple timestamps)
  inviteSentAt    DateTime?
  rsvpReminderSentAt DateTime?
  matchRevealSentAt DateTime?
  eventReminderSentAt DateTime?
  questionSetNotifiedAt DateTime?  // Last time notified about question sets

  // Match view tracking
  matchesFirstViewedAt DateTime?  // When attendee first viewed their matches
  matchesLastViewedAt  DateTime?  // When attendee last viewed their matches

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([eventId, email])
  @@index([eventId])
  @@index([rsvpStatus])
  @@index([experienceLevel])
  @@index([eventId, displayOrder])  // Composite index for efficient ordering queries
  @@index([userId])                 // M33T invitee: Find all events for a user
}

// ========== M33T EVENT ORGANIZER MODEL ==========

model EventOrganizer {
  id        String   @id @default(cuid())
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  // Permissions
  canInvite   Boolean @default(true)   // Can add guests from their contacts
  canCurate   Boolean @default(true)   // Can suggest/override match recommendations
  canEdit     Boolean @default(false)  // Can modify event details
  canManage   Boolean @default(false)  // Can add/remove other organizers

  // Invitation tracking
  invitedAt   DateTime @default(now())
  acceptedAt  DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

// ========== M33T MATCH MODEL ==========

model Match {
  id              String   @id @default(cuid())
  eventId         String
  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // The attendee receiving this match recommendation
  attendeeId      String
  attendee        EventAttendee @relation("AttendeeMatches", fields: [attendeeId], references: [id], onDelete: Cascade)

  // The person they're matched with
  matchedWithId   String
  matchedWith     EventAttendee @relation("MatchedWithAttendee", fields: [matchedWithId], references: [id], onDelete: Cascade)

  // Position in attendee's match list
  position        Int

  // Scoring
  score           Float    // 0-100

  // Explanation
  whyMatch        String[] // Array of reasons (2-3 items)
  conversationStarters String[] // Array of prompts (2-3 items)

  // Status
  status          MatchStatus @default(PENDING)

  // Organizer curation
  isManual        Boolean  @default(false)
  curatorNotes    String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([eventId, attendeeId, matchedWithId])
  @@index([eventId])
  @@index([attendeeId])
  @@index([status])
}

// ========== M33T PHONE VERIFICATION OTP MODEL ==========

model PhoneVerificationOTP {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  phone       String   // Phone being verified (E.164 format)
  code        String   // 6-digit OTP (hashed with SHA-256)
  expiresAt   DateTime // Set to 5 minutes from creation
  attempts    Int      @default(0)   // Max 3 attempts
  verified    Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([phone, code])  // Fast lookup for verification
}
